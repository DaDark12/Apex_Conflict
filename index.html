<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Apex Conflict: FPS Simulator</title>
    <!-- Tailwind CSS for clean UI -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Three.js for 3D rendering -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <style>
        /* Custom styles for the 3D canvas */
        body { margin: 0; overflow: hidden; font-family: 'Inter', sans-serif; }
        #game-container { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background-color: #0d1117; }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 10px;
            height: 10px;
            border: 1px solid white;
            border-radius: 50%;
            z-index: 1000;
            pointer-events: none;
        }
        .ui-panel {
            background-color: rgba(17, 24, 39, 0.95);
            backdrop-filter: blur(5px);
            border: 1px solid rgba(75, 85, 99, 0.5);
            border-radius: 1rem;
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.5);
        }
    </style>
</head>
<body>

    <!-- Main Game Container and UI Overlays -->
    <div id="game-container">
        <!-- 3D Canvas will be injected here by three.js -->
    </div>

    <!-- UI Crosshair -->
    <div id="crosshair" class="hidden"></div>

    <!-- Main UI Screens -->
    <div id="ui-overlay" class="fixed inset-0 flex items-center justify-center p-4">
        
        <!-- === 1. Setup Screen (Initial state) === -->
        <div id="setup-screen" class="ui-panel w-full max-w-lg p-8 space-y-6">
            <h1 class="text-3xl font-bold text-white text-center">Apex Conflict Setup</h1>
            <p class="text-gray-400 text-center">Set your username to begin, then choose your loadout.</p>
            <input type="text" id="username-input" placeholder="Enter your custom username" 
                   class="w-full p-3 rounded-lg bg-gray-700 text-white placeholder-gray-400 focus:ring-2 focus:ring-indigo-500 transition duration-150"
                   maxlength="16">
            <div id="loadout-selection" class="space-y-4 pt-4">
                <h2 class="text-xl font-semibold text-white">Select Loadout</h2>
                <select id="weapon-select" class="w-full p-3 rounded-lg bg-gray-700 text-white transition duration-150">
                    <option value="AR">Assault Rifle (AR)</option>
                    <option value="SNIPER">Sniper Rifle</option>
                    <option value="SMG">Submachine Gun (SMG)</option>
                </select>
                <select id="grenade-select" class="w-full p-3 rounded-lg bg-gray-700 text-white transition duration-150">
                    <option value="FRAG">Frag Grenade</option>
                    <option value="SMOKE">Smoke Grenade</option>
                    <option value="FLASH">Flashbang</option>
                </select>
            </div>
            <button id="save-profile-button" class="w-full p-3 bg-indigo-600 text-white font-bold rounded-lg hover:bg-indigo-700 transition duration-150 disabled:bg-indigo-400" disabled>
                Save Profile & Continue
            </button>
            <p id="auth-status" class="text-sm text-center text-yellow-500">Connecting to server...</p>
        </div>

        <!-- === 2. Lobby List Screen === -->
        <div id="lobby-list-screen" class="ui-panel w-full max-w-3xl p-8 space-y-6 hidden">
            <h1 class="text-3xl font-bold text-white">Lobby Selection</h1>
            <p class="text-gray-400">Welcome, <span id="display-username" class="font-bold text-indigo-400"></span>! Your User ID: <span id="display-user-id" class="text-sm text-gray-500"></span></p>

            <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                <button id="create-lobby-button" class="col-span-1 md:col-span-2 p-3 bg-emerald-600 text-white font-bold rounded-lg hover:bg-emerald-700 transition duration-150">
                    + Create New Lobby
                </button>
                <input type="text" id="join-code-input" placeholder="Join Code" 
                       class="p-3 rounded-lg bg-gray-700 text-white placeholder-gray-400 col-span-1">
                <button id="join-lobby-button" class="col-span-1 p-3 bg-blue-600 text-white font-bold rounded-lg hover:bg-blue-700 transition duration-150 disabled:bg-blue-400">
                    Join Private Lobby
                </button>
            </div>
            
            <div id="public-lobbies-container" class="space-y-3 max-h-64 overflow-y-auto pr-2">
                <h2 class="text-xl font-semibold text-white border-b border-gray-700 pb-2">Public Matches</h2>
                <!-- Lobby list items will be injected here -->
            </div>
        </div>

        <!-- === 3. Game Lobby Screen === -->
        <div id="game-lobby-screen" class="ui-panel w-full max-w-xl p-8 space-y-6 hidden">
            <h1 class="text-3xl font-bold text-white" id="current-lobby-name">Lobby: Unknown</h1>
            <p class="text-gray-400" id="current-lobby-info"></p>
            <div id="lobby-players-list" class="space-y-2 p-3 bg-gray-700 rounded-lg max-h-48 overflow-y-auto">
                <h2 class="text-lg font-semibold text-white">Players (0)</h2>
            </div>
            
            <div class="flex space-x-4">
                <button id="leave-lobby-button" class="flex-1 p-3 bg-red-600 text-white font-bold rounded-lg hover:bg-red-700 transition duration-150">
                    Leave
                </button>
                <button id="start-game-button" class="flex-1 p-3 bg-purple-600 text-white font-bold rounded-lg hover:bg-purple-700 transition duration-150 disabled:bg-purple-400">
                    Start Match (Host Only)
                </button>
            </div>
        </div>
        
        <!-- === 4. Create Lobby Modal === -->
        <div id="create-lobby-modal" class="fixed inset-0 bg-black bg-opacity-75 hidden items-center justify-center z-[2000]">
            <div class="ui-panel p-8 w-full max-w-sm space-y-5">
                <h3 class="text-2xl font-bold text-white">Create New Match</h3>
                
                <div>
                    <label for="new-lobby-name" class="block text-sm font-medium text-gray-400">Lobby Name</label>
                    <input type="text" id="new-lobby-name" placeholder="Alpha Server" maxlength="24"
                           class="w-full p-2 mt-1 rounded-lg bg-gray-700 text-white border border-gray-600 focus:ring-indigo-500" required>
                </div>
                
                <div>
                    <label for="new-lobby-mode" class="block text-sm font-medium text-gray-400">Game Mode</label>
                    <select id="new-lobby-mode" class="w-full p-2 mt-1 rounded-lg bg-gray-700 text-white border border-gray-600">
                        <option value="PVP">Player vs Player (PVP)</option>
                        <option value="ZOMBIE">Kill The Zombies (PVE)</option>
                    </select>
                </div>
                
                <div class="flex items-center">
                    <input id="new-lobby-private" type="checkbox" class="h-4 w-4 text-indigo-600 bg-gray-700 border-gray-600 rounded focus:ring-indigo-500">
                    <label for="new-lobby-private" class="ml-2 text-sm font-medium text-gray-300">Private Match (Shareable Code)</label>
                </div>

                <div class="flex space-x-3 pt-3">
                    <button id="confirm-create-lobby-button" class="flex-1 p-3 bg-indigo-600 text-white font-bold rounded-lg hover:bg-indigo-700 transition duration-150">
                        Create Lobby
                    </button>
                    <button id="cancel-create-lobby-button" class="flex-1 p-3 bg-gray-600 text-white font-bold rounded-lg hover:bg-gray-700 transition duration-150">
                        Cancel
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Status Message Box (Replaces alert()) -->
    <div id="message-box" class="fixed bottom-4 left-1/2 transform -translate-x-1/2 p-3 rounded-lg text-white font-semibold shadow-lg hidden transition-opacity duration-300 z-[3000]">
        <!-- Messages appear here -->
    </div>

    <!-- === GAME SCRIPT MODULE === -->
    <script type="module">
        // --- FIREBASE IMPORTS ---
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, deleteDoc, onSnapshot, collection, query, where, addDoc, updateDoc, getDocs, runTransaction, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        // Enable Firebase debugging logs
        setLogLevel('Debug');

        // --- GLOBAL & FIREBASE SETUP ---
        let app;
        let db;
        let auth;
        let userId = '';
        let username = '';
        let playerRef;
        let lobbyRef;
        let currentLobbyId = null;
        let isHost = false;
        let isGameStarted = false;
        let unsubscribeLobby = null;

        // CRITICAL FIX: Fallback config ensures 'projectId' exists.
        const DEFAULT_FIREBASE_CONFIG = {
            apiKey: "AIzaSy_MOCKED_API_KEY_12345", 
            authDomain: "mock-project.firebaseapp.com",
            projectId: "mock-project-id",
            storageBucket: "mock-project.appspot.com",
            messagingSenderId: "123456789012",
            appId: "1:123456789012:web:abcdef1234567890",
        };
        
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        
        const firebaseConfig = (() => {
            try {
                if (typeof __firebase_config !== 'undefined' && __firebase_config) {
                    return JSON.parse(__firebase_config);
                }
            } catch (e) {
                console.error("Error parsing __firebase_config, using default:", e);
            }
            console.warn("Using mock Firebase configuration for local development.");
            return DEFAULT_FIREBASE_CONFIG;
        })();

        // --- THREE.JS GLOBALS ---
        let scene, camera, renderer;
        let controls;
        const players = {}; // Stores all player 3D objects
        const MOVEMENT_SPEED = 0.05;
        const ROTATION_SPEED = 0.002;
        let isPointerLocked = false;

        // --- UI ELEMENTS ---
        const uiElements = {
            setupScreen: document.getElementById('setup-screen'),
            lobbyListScreen: document.getElementById('lobby-list-screen'),
            gameLobbyScreen: document.getElementById('game-lobby-screen'),
            createLobbyModal: document.getElementById('create-lobby-modal'),
            usernameInput: document.getElementById('username-input'),
            saveProfileButton: document.getElementById('save-profile-button'),
            authStatus: document.getElementById('auth-status'),
            displayUserId: document.getElementById('display-user-id'),
            displayUsername: document.getElementById('display-username'),
            createLobbyButton: document.getElementById('create-lobby-button'),
            joinCodeInput: document.getElementById('join-code-input'),
            joinLobbyButton: document.getElementById('join-lobby-button'),
            publicLobbiesContainer: document.getElementById('public-lobbies-container'),
            currentLobbyName: document.getElementById('current-lobby-name'),
            lobbyPlayersList: document.getElementById('lobby-players-list'),
            leaveLobbyButton: document.getElementById('leave-lobby-button'),
            startGameButton: document.getElementById('start-game-button'),
            newLoadout: {
                weapon: document.getElementById('weapon-select'),
                grenade: document.getElementById('grenade-select'),
            },
            newModal: {
                name: document.getElementById('new-lobby-name'),
                mode: document.getElementById('new-lobby-mode'),
                private: document.getElementById('new-lobby-private'),
                confirm: document.getElementById('confirm-create-lobby-button'),
                cancel: document.getElementById('cancel-create-lobby-button'),
            },
            crosshair: document.getElementById('crosshair'),
            messageBox: document.getElementById('message-box'),
        };

        // --- STATE VARIABLES ---
        let playerProfile = {
            username: '',
            loadout: { weapon: 'AR', grenade: 'FRAG' },
            health: 100,
            x: 0, y: 1, z: 0,
            rotY: 0, // Vertical camera rotation
            rotX: 0, // Horizontal body rotation
        };

        // --- UTILITY FUNCTIONS ---

        /** Shows a temporary status message to the user. */
        function showMessage(text, type = 'info') {
            const box = uiElements.messageBox;
            box.textContent = text;
            
            box.className = 'fixed bottom-4 left-1/2 transform -translate-x-1/2 p-3 rounded-lg text-white font-semibold shadow-lg transition-opacity duration-300 z-[3000]';
            
            switch (type) {
                case 'error':
                    box.classList.add('bg-red-600');
                    break;
                case 'success':
                    box.classList.add('bg-emerald-600');
                    break;
                case 'warn':
                    box.classList.add('bg-yellow-600');
                    break;
                case 'info':
                default:
                    box.classList.add('bg-blue-600');
                    break;
            }
            
            box.classList.remove('hidden');
            box.style.opacity = '1';

            setTimeout(() => {
                box.style.opacity = '0';
                setTimeout(() => {
                    box.classList.add('hidden');
                }, 300);
            }, 3000);
        }

        /** Hides all main UI screens. */
        function hideAllScreens() {
            Object.values(uiElements).forEach(el => {
                if (el.id && el.id.endsWith('-screen')) {
                    el.classList.add('hidden');
                }
            });
            uiElements.createLobbyModal.classList.add('hidden');
            uiElements.uiOverlay.classList.remove('hidden');
            // Hide the crosshair when in menus
            uiElements.crosshair.classList.add('hidden');
        }
        
        /** Gets the correct Firestore path for a public collection */
        function getPublicCollection(collectionName) {
            return collection(db, 'artifacts', appId, 'public/data', collectionName);
        }

        // --- FIREBASE LOGIC ---

        /** Initializes Firebase services and authentication. */
        async function initFirebase() {
            try {
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        userId = user.uid;
                        uiElements.authStatus.textContent = 'Connected. Please set up your profile.';
                        uiElements.displayUserId.textContent = userId;
                        
                        // Check if a profile already exists
                        const profileDoc = await getDoc(doc(getPublicCollection('profiles'), userId));
                        if (profileDoc.exists()) {
                            playerProfile = profileDoc.data();
                            username = playerProfile.username;
                            
                            // Pre-fill UI
                            uiElements.usernameInput.value = username;
                            uiElements.newLoadout.weapon.value = playerProfile.loadout.weapon;
                            uiElements.newLoadout.grenade.value = playerProfile.loadout.grenade;
                            
                            showMessage(`Welcome back, ${username}!`, 'success');
                            showLobbyListScreen();
                        } else {
                            uiElements.saveProfileButton.disabled = false;
                        }

                    } else {
                        // Attempt to sign in anonymously if no token provided
                        if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                            await signInWithCustomToken(auth, __initial_auth_token);
                        } else {
                            await signInAnonymously(auth);
                        }
                    }
                });

            } catch (e) {
                console.error("Firebase Initialization Error:", e);
                uiElements.authStatus.textContent = `Error connecting to Firebase: ${e.message}`;
                showMessage('Firebase connection failed. Check console for details.', 'error');
            }
        }
        
        /** Saves the user profile and moves to the lobby list. */
        async function saveProfile() {
            username = uiElements.usernameInput.value.trim();
            if (username.length < 3) {
                showMessage('Username must be at least 3 characters.', 'warn');
                return;
            }
            
            playerProfile.username = username;
            playerProfile.loadout.weapon = uiElements.newLoadout.weapon.value;
            playerProfile.loadout.grenade = uiElements.newLoadout.grenade.value;

            try {
                await setDoc(doc(getPublicCollection('profiles'), userId), playerProfile);
                uiElements.displayUsername.textContent = username;
                showMessage('Profile saved!', 'success');
                showLobbyListScreen();
            } catch (e) {
                console.error("Error saving profile:", e);
                showMessage('Error saving profile. Try again.', 'error');
            }
        }

        /** Starts listening for public lobbies. */
        function listenForLobbies() {
            const lobbiesCollection = getPublicCollection('lobbies');
            const q = query(lobbiesCollection, where('isPrivate', '==', false));

            onSnapshot(q, (snapshot) => {
                const container = uiElements.publicLobbiesContainer;
                container.innerHTML = `<h2 class="text-xl font-semibold text-white border-b border-gray-700 pb-2">Public Matches (${snapshot.size})</h2>`;
                
                if (snapshot.empty) {
                    container.innerHTML += `<p class="text-gray-500 italic mt-2">No public lobbies found. Be the first!</p>`;
                }
                
                snapshot.forEach(doc => {
                    const lobby = doc.data();
                    const lobbyId = doc.id;
                    const el = document.createElement('div');
                    el.className = 'flex justify-between items-center p-3 bg-gray-800 rounded-lg hover:bg-gray-700 cursor-pointer';
                    el.innerHTML = `
                        <div>
                            <p class="text-white font-bold">${lobby.name}</p>
                            <p class="text-sm text-gray-400">${lobby.players.length} / 10 players | Mode: ${lobby.mode}</p>
                        </div>
                        <button class="join-lobby-btn p-2 bg-blue-500 rounded-lg text-xs font-semibold hover:bg-blue-600" data-id="${lobbyId}">
                            Join
                        </button>
                    `;
                    container.appendChild(el);
                    
                    el.querySelector('.join-lobby-btn').addEventListener('click', () => joinLobby(lobbyId));
                });
            }, (error) => {
                console.error("Error listening to lobbies:", error);
            });
        }
        
        /** Creates a new game lobby. */
        async function createLobby() {
            const name = uiElements.newModal.name.value.trim();
            const mode = uiElements.newModal.mode.value;
            const isPrivate = uiElements.newModal.private.checked;

            if (name.length < 3) {
                showMessage('Lobby name must be at least 3 characters.', 'warn');
                return;
            }
            
            try {
                const lobbiesCollection = getPublicCollection('lobbies');
                const newLobby = {
                    name,
                    hostId: userId,
                    mode,
                    isPrivate,
                    isGameStarted: false,
                    joinCode: isPrivate ? Math.random().toString(36).substring(2, 8).toUpperCase() : null,
                    players: [{ 
                        id: userId, 
                        username: playerProfile.username, 
                        loadout: playerProfile.loadout,
                        isHost: true
                    }],
                    createdAt: serverTimestamp(),
                };

                const docRef = await addDoc(lobbiesCollection, newLobby);
                currentLobbyId = docRef.id;
                isHost = true;
                showMessage(`Lobby '${name}' created!`, 'success');
                uiElements.createLobbyModal.classList.add('hidden');
                showGameLobbyScreen();
                listenToLobbyChanges(currentLobbyId);

            } catch (e) {
                console.error("Error creating lobby:", e);
                showMessage('Failed to create lobby. Try again.', 'error');
            }
        }
        
        /** Attempts to join an existing lobby by ID or Code. */
        async function joinLobby(lobbyIdentifier) {
            if (currentLobbyId) return; // Already in a lobby

            let lobbyToJoin = null;
            let lobbyRefToJoin = null;
            
            try {
                // 1. Check if identifier is a direct ID
                const docRefById = doc(getPublicCollection('lobbies'), lobbyIdentifier);
                const docSnapById = await getDoc(docRefById);

                if (docSnapById.exists()) {
                    lobbyToJoin = docSnapById.data();
                    lobbyRefToJoin = docRefById;
                } else {
                    // 2. Check if identifier is a joinCode
                    const q = query(getPublicCollection('lobbies'), where('joinCode', '==', lobbyIdentifier.toUpperCase()));
                    const querySnapshot = await getDocs(q);
                    
                    if (!querySnapshot.empty) {
                        const docSnapByCode = querySnapshot.docs[0];
                        lobbyToJoin = docSnapByCode.data();
                        lobbyRefToJoin = docSnapByCode.ref;
                        lobbyIdentifier = docSnapByCode.id; // Use the actual ID now
                    }
                }
                
                if (!lobbyToJoin || !lobbyRefToJoin) {
                    showMessage('Lobby not found or code is invalid.', 'error');
                    return;
                }

                // Use transaction to safely add player
                await runTransaction(db, async (transaction) => {
                    const currentLobbySnap = await transaction.get(lobbyRefToJoin);
                    if (!currentLobbySnap.exists()) {
                        throw new Error("Lobby disappeared!");
                    }
                    const lobbyData = currentLobbySnap.data();
                    
                    if (lobbyData.players.some(p => p.id === userId)) {
                        // Already in lobby (shouldn't happen, but good check)
                        return;
                    }
                    
                    if (lobbyData.isGameStarted) {
                        throw new Error("Game has already started.");
                    }
                    
                    const newPlayer = {
                        id: userId, 
                        username: playerProfile.username, 
                        loadout: playerProfile.loadout,
                        isHost: false
                    };
                    
                    transaction.update(lobbyRefToJoin, {
                        players: [...lobbyData.players, newPlayer]
                    });
                    
                    currentLobbyId = lobbyIdentifier;
                    isHost = false;
                    showMessage(`Joined lobby: ${lobbyToJoin.name}`, 'success');
                });
                
                showGameLobbyScreen();
                listenToLobbyChanges(currentLobbyId);

            } catch (e) {
                console.error("Error joining lobby:", e);
                showMessage(e.message || 'Failed to join lobby.', 'error');
                currentLobbyId = null;
            }
        }
        
        /** Removes the current user from the lobby. */
        async function leaveLobby() {
            if (!currentLobbyId) return;
            
            try {
                const lobbyRefToLeave = doc(getPublicCollection('lobbies'), currentLobbyId);

                await runTransaction(db, async (transaction) => {
                    const currentLobbySnap = await transaction.get(lobbyRefToLeave);
                    if (!currentLobbySnap.exists()) return;
                    
                    const lobbyData = currentLobbySnap.data();
                    
                    const updatedPlayers = lobbyData.players.filter(p => p.id !== userId);
                    
                    if (updatedPlayers.length === 0) {
                        // Last player leaves, delete the lobby
                        transaction.delete(lobbyRefToLeave);
                    } else if (isHost) {
                        // Host leaves, assign new host (first player in list)
                        updatedPlayers[0].isHost = true;
                        transaction.update(lobbyRefToLeave, {
                            hostId: updatedPlayers[0].id,
                            players: updatedPlayers
                        });
                    } else {
                        // Regular player leaves
                        transaction.update(lobbyRefToLeave, {
                            players: updatedPlayers
                        });
                    }
                });
                
                // Cleanup local state and UI
                if (unsubscribeLobby) unsubscribeLobby();
                currentLobbyId = null;
                isHost = false;
                isGameStarted = false;
                showMessage('You have left the lobby.', 'info');
                showLobbyListScreen();
                
                // Stop 3D game if running
                stopGame(); 

            } catch (e) {
                console.error("Error leaving lobby:", e);
                showMessage('Error leaving lobby.', 'error');
            }
        }
        
        /** Listens to real-time changes within the current lobby document. */
        function listenToLobbyChanges(lobbyId) {
            if (unsubscribeLobby) unsubscribeLobby();
            
            lobbyRef = doc(getPublicCollection('lobbies'), lobbyId);
            
            unsubscribeLobby = onSnapshot(lobbyRef, (docSnap) => {
                if (!docSnap.exists()) {
                    // Lobby was deleted (e.g., last player left)
                    if (currentLobbyId) {
                        showMessage('Lobby was closed by the host or the last player.', 'warn');
                        leaveLobbyCleanup();
                    }
                    return;
                }
                
                const lobby = docSnap.data();
                
                // Update lobby UI
                uiElements.currentLobbyName.textContent = `Lobby: ${lobby.name}`;
                if (lobby.joinCode) {
                    uiElements.currentLobbyInfo.textContent = `Private Code: ${lobby.joinCode} | Mode: ${lobby.mode}`;
                } else {
                    uiElements.currentLobbyInfo.textContent = `Mode: ${lobby.mode} (Public)`;
                }
                
                // Update player list
                const list = uiElements.lobbyPlayersList;
                list.innerHTML = `<h2 class="text-lg font-semibold text-white">Players (${lobby.players.length})</h2>`;
                lobby.players.forEach(p => {
                    const el = document.createElement('p');
                    const hostIndicator = p.isHost ? ' <span class="text-xs text-yellow-400">(HOST)</span>' : '';
                    const youIndicator = p.id === userId ? ' <span class="text-xs text-indigo-400">(YOU)</span>' : '';
                    el.className = 'text-gray-300';
                    el.innerHTML = `${p.username}${hostIndicator}${youIndicator} - ${p.loadout.weapon}`;
                    list.appendChild(el);
                    
                    // Update host status locally if changed
                    if (p.id === userId) {
                        isHost = p.isHost;
                    }
                });
                
                // Host-only UI changes
                uiElements.startGameButton.classList.toggle('hidden', !isHost);
                uiElements.startGameButton.disabled = lobby.players.length < 2; // Need at least 2 players
                
                // Check if game has started
                if (lobby.isGameStarted && !isGameStarted) {
                    isGameStarted = true;
                    startGame(lobby.players);
                }
                
            }, (error) => {
                console.error("Error processing lobby update:", error);
            });
        }
        
        /** Cleans up when the lobby is closed externally */
        function leaveLobbyCleanup() {
            if (unsubscribeLobby) unsubscribeLobby();
            currentLobbyId = null;
            isHost = false;
            isGameStarted = false;
            showLobbyListScreen();
            stopGame();
        }
        
        /** Host initiates the game state change in Firestore. */
        async function hostStartGame() {
            if (!isHost || isGameStarted) return;
            
            try {
                await updateDoc(lobbyRef, {
                    isGameStarted: true,
                    // Initialize player positions
                    // Note: Actual player sync will be handled by a dedicated 'game' subcollection
                });
                showMessage('Match starting!', 'success');
            } catch (e) {
                console.error("Error starting game:", e);
                showMessage('Could not start game. Try again.', 'error');
            }
        }

        // --- GAME LOGIC ---

        /** Initializes the 3D scene and environment. */
        function initThreeJS() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0d1117);

            // Camera setup: First-Person Perspective
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 1, 0); // Player height is 1 unit

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('game-container').appendChild(renderer.domElement);

            // Lighting: Simple ambient + directional
            const ambientLight = new THREE.AmbientLight(0x404040, 5); // soft white light
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
            directionalLight.position.set(5, 10, 7.5);
            scene.add(directionalLight);

            // Simple Arena (The Floor)
            const floorGeometry = new THREE.PlaneGeometry(50, 50);
            const floorMaterial = new THREE.MeshPhongMaterial({ color: 0x1f2937, side: THREE.DoubleSide });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = Math.PI / 2;
            floor.position.y = 0;
            scene.add(floor);
            
            // Simple walls (for visual reference)
            const wallMaterial = new THREE.MeshPhongMaterial({ color: 0x374151 });
            const wallGeometry = new THREE.BoxGeometry(50, 5, 0.5);

            const wall1 = new THREE.Mesh(wallGeometry, wallMaterial);
            wall1.position.z = -25;
            wall1.position.y = 2.5;
            scene.add(wall1);
            
            const wall2 = new THREE.Mesh(wallGeometry, wallMaterial);
            wall2.position.z = 25;
            wall2.position.y = 2.5;
            scene.add(wall2);

            const wall3 = new THREE.Mesh(new THREE.BoxGeometry(0.5, 5, 50), wallMaterial);
            wall3.position.x = -25;
            wall3.position.y = 2.5;
            scene.add(wall3);

            const wall4 = new THREE.Mesh(new THREE.BoxGeometry(0.5, 5, 50), wallMaterial);
            wall4.position.x = 25;
            wall4.position.y = 2.5;
            scene.add(wall4);

            window.addEventListener('resize', onWindowResize);
            
            // Set up initial player position
            playerProfile.x = 0;
            playerProfile.y = 1;
            playerProfile.z = 0;
            camera.position.set(playerProfile.x, playerProfile.y, playerProfile.z);
        }
        
        /** Handles window resizing to keep the aspect ratio correct. */
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        /** Creates the visual representation for another player (a simple capsule). */
        function createPlayerMesh(id, username, color = 0xff0000) {
            const geometry = new THREE.CapsuleGeometry(0.3, 1.0, 4, 8);
            const material = new THREE.MeshBasicMaterial({ color: color });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.y = 1; 
            mesh.name = username;
            
            // Add a simple name tag (using a sprite, though complex in one file)
            // For simplicity, we'll just track the mesh itself.
            scene.add(mesh);
            players[id] = { mesh, username, lastUpdate: Date.now() };
        }
        
        /** Removes a player's mesh from the scene. */
        function removePlayerMesh(id) {
            if (players[id] && players[id].mesh) {
                scene.remove(players[id].mesh);
                delete players[id];
            }
        }

        // --- GAME SYNCHRONIZATION ---

        /** Sets up real-time listener for game state/player movement. */
        function listenToGameSync() {
            const gameCollection = collection(db, 'artifacts', appId, 'public/data', 'game_sync', currentLobbyId, 'players');

            onSnapshot(gameCollection, (snapshot) => {
                snapshot.docChanges().forEach(change => {
                    const data = change.doc.data();
                    const playerId = change.doc.id;

                    if (playerId === userId) return; // Ignore self updates

                    if (change.type === 'added') {
                        if (!players[playerId]) {
                            createPlayerMesh(playerId, data.username, data.isHost ? 0x00ff00 : 0x0000ff);
                        }
                    } else if (change.type === 'modified') {
                        if (players[playerId]) {
                            // Interpolate movement (simple approach)
                            players[playerId].mesh.position.set(data.x, data.y, data.z);
                            players[playerId].mesh.rotation.y = data.rotX;
                            players[playerId].lastUpdate = Date.now();
                        }
                    } else if (change.type === 'removed') {
                        removePlayerMesh(playerId);
                        showMessage(`${data.username} left the match.`, 'info');
                    }
                });
            });
            
            // Create self player reference for writing
            playerRef = doc(gameCollection, userId);
            
            // Initial write of self state
            updateSelfPosition(true);
        }
        
        /** Writes the player's current position and state to Firestore. */
        async function updateSelfPosition(isInitial = false) {
            if (!playerRef || !isGameStarted) return;
            
            const positionData = {
                username: playerProfile.username,
                isHost: isHost,
                x: camera.position.x,
                y: camera.position.y,
                z: camera.position.z,
                rotX: playerProfile.rotX, // Horizontal body rotation (for mesh)
                rotY: playerProfile.rotY, // Vertical camera rotation (less important for other players' mesh)
                health: playerProfile.health,
                updatedAt: serverTimestamp(),
            };
            
            try {
                if (isInitial) {
                    await setDoc(playerRef, positionData);
                } else {
                    await updateDoc(playerRef, positionData);
                }
            } catch (e) {
                console.error("Failed to sync position:", e);
                // Non-critical error, but log it
            }
        }
        
        // --- GAME LOOP & CONTROLS ---

        let keys = { w: false, a: false, s: false, d: false, space: false };
        let lastSyncTime = 0;
        const SYNC_INTERVAL = 100; // Sync position 10 times per second (100ms)

        function animate(time) {
            requestAnimationFrame(animate);

            if (isGameStarted) {
                // 1. Handle Movement (Input)
                if (isPointerLocked) {
                    const deltaTime = 1000 / 60; // Assuming ~60 FPS
                    const velocity = new THREE.Vector3();

                    // Movement is relative to the camera's current direction
                    let moveX = 0, moveZ = 0;
                    if (keys.w) moveZ -= 1;
                    if (keys.s) moveZ += 1;
                    if (keys.a) moveX -= 1;
                    if (keys.d) moveX += 1;
                    
                    const direction = new THREE.Vector3(moveX, 0, moveZ).normalize();
                    
                    // Rotate movement vector to align with camera's horizontal rotation
                    const rotationMatrix = new THREE.Matrix4().makeRotationY(camera.rotation.y);
                    direction.applyMatrix4(rotationMatrix);
                    
                    if (moveX !== 0 || moveZ !== 0) {
                        camera.position.x += direction.x * MOVEMENT_SPEED * deltaTime;
                        camera.position.z += direction.z * MOVEMENT_SPEED * deltaTime;
                        
                        // 2. Sync Position (Output)
                        if (Date.now() - lastSyncTime > SYNC_INTERVAL) {
                            updateSelfPosition();
                            lastSyncTime = Date.now();
                        }
                    }
                }
            }

            renderer.render(scene, camera);
        }
        
        // --- POINTER LOCK & EVENT HANDLERS ---
        
        function setupControls() {
            // Mouse Look
            document.addEventListener('mousemove', (event) => {
                if (isPointerLocked) {
                    // Yaw (Horizontal Rotation - applied to body/mesh)
                    playerProfile.rotX -= event.movementX * ROTATION_SPEED;
                    camera.rotation.y = playerProfile.rotX;
                    
                    // Pitch (Vertical Rotation - applied to camera)
                    playerProfile.rotY -= event.movementY * ROTATION_SPEED;
                    playerProfile.rotY = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, playerProfile.rotY));
                    camera.rotation.x = playerProfile.rotY;
                }
            });

            // Keyboard Input
            document.addEventListener('keydown', (event) => {
                if (!isGameStarted || !isPointerLocked) return;
                switch (event.key.toLowerCase()) {
                    case 'w': keys.w = true; break;
                    case 'a': keys.a = true; break;
                    case 's': keys.s = true; break;
                    case 'd': keys.d = true; break;
                    case ' ': keys.space = true; break;
                }
            });

            document.addEventListener('keyup', (event) => {
                if (!isGameStarted || !isPointerLocked) return;
                switch (event.key.toLowerCase()) {
                    case 'w': keys.w = false; break;
                    case 'a': keys.a = false; break;
                    case 's': keys.s = false; break;
                    case 'd': keys.d = false; break;
                    case ' ': keys.space = false; break;
                }
            });
            
            // Pointer Lock Events
            document.addEventListener('pointerlockchange', () => {
                isPointerLocked = document.pointerLockElement === document.body;
                if (isPointerLocked) {
                    uiElements.uiOverlay.classList.add('hidden');
                    uiElements.crosshair.classList.remove('hidden');
                } else if (isGameStarted) {
                    uiElements.uiOverlay.classList.remove('hidden');
                    uiElements.crosshair.classList.add('hidden');
                    // Show a pause/disconnect message here in a real game
                    showMessage('Game Paused. Click to resume.', 'warn');
                }
            });

            // Enter Game
            document.body.addEventListener('click', () => {
                if (isGameStarted && !isPointerLocked) {
                    document.body.requestPointerLock();
                }
            });
        }

        // --- SCREEN MANAGEMENT ---
        
        function showSetupScreen() {
            hideAllScreens();
            uiElements.setupScreen.classList.remove('hidden');
        }

        function showLobbyListScreen() {
            hideAllScreens();
            uiElements.lobbyListScreen.classList.remove('hidden');
            listenForLobbies();
        }

        function showGameLobbyScreen() {
            hideAllScreens();
            uiElements.gameLobbyScreen.classList.remove('hidden');
            // Hide the game environment/canvas for now, only showing the lobby UI
        }
        
        function startGame(playersInLobby) {
            // Hide all UI
            hideAllScreens();
            uiElements.uiOverlay.classList.add('hidden');
            
            // Ensure 3D is running and game flags are set
            isGameStarted = true;
            showMessage('Game is LIVE! Click to enter the arena.', 'success');
            
            // Clear existing player meshes
            Object.keys(players).forEach(id => removePlayerMesh(id));
            
            // Re-create meshes for other players in the game (excluding self)
            playersInLobby.forEach(p => {
                if (p.id !== userId) {
                    createPlayerMesh(p.id, p.username, p.isHost ? 0x00ff00 : 0x0000ff);
                }
            });
            
            // Start listening to live player positions
            listenToGameSync();
            
            // Automatically try to engage pointer lock
            document.body.requestPointerLock();
        }
        
        function stopGame() {
             isGameStarted = false;
             document.exitPointerLock();
             Object.keys(players).forEach(id => removePlayerMesh(id));
             if (playerRef) {
                 // Remove self from the game_sync subcollection
                 deleteDoc(playerRef);
                 playerRef = null;
             }
        }

        // --- EVENT LISTENERS ---
        
        window.onload = () => {
            initThreeJS();
            setupControls();
            initFirebase(); 
            animate(0); // Start the main loop
        };
        
        uiElements.usernameInput.addEventListener('input', () => {
            uiElements.saveProfileButton.disabled = uiElements.usernameInput.value.trim().length < 3;
        });

        uiElements.saveProfileButton.addEventListener('click', saveProfile);
        
        uiElements.createLobbyButton.addEventListener('click', () => {
            uiElements.createLobbyModal.style.display = 'flex';
        });
        
        uiElements.newModal.cancel.addEventListener('click', () => {
            uiElements.createLobbyModal.classList.add('hidden');
        });

        uiElements.newModal.confirm.addEventListener('click', createLobby);
        
        uiElements.joinLobbyButton.addEventListener('click', () => {
            const code = uiElements.joinCodeInput.value.trim();
            if (code) {
                joinLobby(code);
            } else {
                showMessage('Please enter a join code.', 'warn');
            }
        });
        
        uiElements.leaveLobbyButton.addEventListener('click', leaveLobby);
        
        uiElements.startGameButton.addEventListener('click', hostStartGame);

    </script>
</body>
</html>
